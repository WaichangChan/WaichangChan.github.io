{"version":3,"sources":["../static/js/1.85d4732e.chunk.js","parts/QuadTreeComp.js","lib/QuadTree.js"],"names":["webpackJsonp","78","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1__lib_QuadTree__","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","QuadTreeComp","_Component","_ref","_temp","_this","_ret","this","_len","arguments","args","Array","_key","getPrototypeOf","apply","concat","canvasRef","quadHandler","handleRef","ref","cleanQuadTree","a","createElement","className","82","renderQuadTree","cvs","mainLoop","timepass","ctx","clearRect","cvsWidth","cvsHeight","quadTree","clear","objList","forEach","rect","move","overlap","setObjects","render","fps","lasttime","fillText","animateInit","animateId","window","requestAnimationFrame","getContext","width","height","maxWidth","maxHeight","Rect","right","bottom","push","Math","random","QuadTree","cancelAnimationFrame","_this2","item","root","add","collision","drawNode","showTargets","getObjectsByBound","bound","fillStyle","fillRect","left","top","Node","maxObjPerNode","maxLevel","level","_initialiseProps","objects","childNodes","cleaned","LEFT_TOP","LEFT_BOTTOM","RIGHT_BOTTOM","RIGHT_TOP","_this4","strokeRect","overlapObj","obj","bd","save","restore","child","rectOverRect","objs","size","k","bound1","bound2","index","getIndex","split","halfWidth","halfHeight","tmpObjects","objRect","rightBottomNode","isBottom","isTop","objBound","returnObjs","x","y","w","h","_this3","step","stepX","stepY"],"mappings":"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","file":"static/js/1.85d4732e.chunk.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 78:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_QuadTree__ = __webpack_require__(82);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var QuadTreeComp=function(_Component){_inherits(QuadTreeComp,_Component);function QuadTreeComp(){var _ref;var _temp,_this,_ret;_classCallCheck(this,QuadTreeComp);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=QuadTreeComp.__proto__||Object.getPrototypeOf(QuadTreeComp)).call.apply(_ref,[this].concat(args))),_this),_this.canvasRef=null,_this.quadHandler=null,_this.handleRef=function(ref){if(ref){_this.handleRef=ref;_this.quadHandler=Object(__WEBPACK_IMPORTED_MODULE_1__lib_QuadTree__[\"a\" /* renderQuadTree */])(_this.handleRef);}else{_this.quadHandler.cleanQuadTree();}},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(QuadTreeComp,[{key:'render',value:function render(){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('section',{className:'topic-body'},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('h4',null,'\\u56DB\\u53C9\\u6811\\u78B0\\u649E\\u68C0\\u6D4B'),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('canvas',{ref:this.handleRef}));}}]);return QuadTreeComp;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"default\"] = (QuadTreeComp);\n\n/***/ }),\n\n/***/ 82:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = renderQuadTree;\nfunction _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}var QuadTree=function QuadTree(width,height){var _this2=this;_classCallCheck(this,QuadTree);this.setObjects=function(objList){if(objList instanceof Array){objList.forEach(function(item){this.root.add(item);},_this2);}else{_this2.root.add(objList);}_this2.root.collision();};this.clear=function(){_this2.root.clear();};this.render=function(ctx){_this2.root.drawNode(ctx);};this.showTargets=function(ctx,rect){var objList=_this2.root.getObjectsByBound(rect);objList.forEach(function(item){var bound=item.bound;ctx.fillStyle='#F00';ctx.fillRect(bound.left,bound.top,bound.width,bound.height);});};this.root=new Node({'left':0,'top':0,'width':width,'height':height},1);}/*\n   *显示指定区域内的对象\n   */;QuadTree.maxObjPerNode=5;QuadTree.maxLevel=5;var Node=/*\n   *bound 当前节点占据的范围\n   *objects 要添加到节点上的对象数组\n   *bound:{left, top, width, height}\n   *//*\n   **计算当前对象属于四个节点中的哪个\n   * -1表示父节点\n   * 0：左上\n   * 1：左下\n   * 2：右下\n   * 3：右上\n   * 如果返回值是一个数组，说明当前对象跨越了2个以上节点\n   */function Node(bound,level){_classCallCheck(this,Node);_initialiseProps.call(this);this.objects=[];this.childNodes=null;this.bound=bound;this.level=level;this.cleaned=true;//用来区分节点是不是被清除过\n}/**\n   * 分裂节点\n   *//*\n   *获取某个范围内的对象\n   */;Node.LEFT_TOP=0;Node.LEFT_BOTTOM=1;Node.RIGHT_BOTTOM=2;Node.RIGHT_TOP=3;var _initialiseProps=function _initialiseProps(){var _this4=this;this.drawNode=function(ctx){var bound=_this4.bound;_this4.childNodes&&_this4.childNodes.forEach(function(item){item.drawNode(ctx);});_this4.objects.length>0&&ctx.strokeRect(bound.left,bound.top,bound.width,bound.height);var overlapObj=[];_this4.objects.forEach(function(obj){var bd=obj.bound;ctx.strokeRect(bd.left,bd.top,bd.width,bd.height);obj.overlap&&overlapObj.push(bd);});ctx.save();ctx.fillStyle='#F00';overlapObj.forEach(function(bound){ctx.fillRect(bound.left,bound.top,bound.width,bound.height);});ctx.restore();};this.clear=function(){if(_this4.childNodes){_this4.childNodes.forEach(function(child){child.clear();});}_this4.cleaned=true;_this4.objects.length=0;};this.collision=function(){var childNodes=_this4.childNodes;if(childNodes){childNodes.forEach(function(item){item.collision();});var _this=_this4;//对于跨域不同象限的对象，根据对象所属的象限，取出对应象限内所有的对象\n_this4.objects.forEach(function(item){var objects=_this.getObjectsByBound(item.bound);objects.forEach(function(obj){if(_this.rectOverRect(item.bound,obj.bound)){obj.overlap=item.overlap=true;}});});}var objs=_this4.objects;for(var i=0,size=objs.length;i<size;i++){for(var k=i+1;k<size;k++){if(_this4.rectOverRect(objs[i].bound,objs[k].bound)){objs[i].overlap=objs[k].overlap=true;}}}};this.rectOverRect=function(bound1,bound2){return!(bound1.left+bound1.width<bound2.left||bound1.left>bound2.left+bound2.width||bound1.top+bound1.height<bound2.top||bound1.top>bound2.top+bound2.height);};this.add=function(obj){if(!obj||!obj.bound){throw new TypeError('arguments must contain {bound}');}if(!_this4.cleaned&&_this4.childNodes&&_this4.childNodes.length>0){var index=_this4.getIndex(obj.bound);if(index>-1){return _this4.childNodes[index].add(obj);}}else if(_this4.objects.length>QuadTree.maxObjPerNode&&_this4.level<QuadTree.maxLevel){_this4.split();var _index=_this4.getIndex(obj.bound);if(_index>-1){return _this4.childNodes[_index].add(obj);}}//obj.quadrant = index;\n_this4.objects.push(obj);};this.split=function(){var bound=_this4.bound;var halfWidth=bound.width/2>>0,halfHeight=bound.height/2>>0;var level=_this4.level+1;!_this4.childNodes&&(_this4.childNodes=[new Node({'left':bound.left,'top':bound.top,'width':halfWidth,'height':halfHeight},level),//0：左上\nnew Node({'left':bound.left,'top':bound.top+halfHeight,'width':halfWidth,'height':halfHeight},level),//1：左下\nnew Node({'left':bound.left+halfWidth,'top':bound.top+halfHeight,'width':halfWidth,'height':halfHeight},level),//2：右下\nnew Node({'left':bound.left+halfWidth,'top':bound.top,'width':halfWidth,'height':halfHeight},level)//3：右上\n]);var tmpObjects=[];_this4.objects.forEach(function(item){var index=this.getIndex(item.bound);if(-1<index){this.childNodes[index].add(item);}else{tmpObjects.push(item);}},_this4);_this4.cleaned=false;_this4.objects=tmpObjects;};this.getIndex=function(objRect){if(_this4.childNodes){var rightBottomNode=_this4.childNodes[2].bound;var isBottom=objRect.top>=rightBottomNode.top;var isTop=objRect.top+objRect.height<=rightBottomNode.top;//判断位置是偏右还是偏左\nif(objRect.left>=rightBottomNode.left){//偏右\nif(isTop){//右上\nreturn 3;}else if(isBottom){//右下\nreturn 2;}else{return[2,3];}}else if(objRect.left+objRect.width<=rightBottomNode.left){//偏左\nif(isTop){//左上\nreturn 0;}else if(isBottom){//左下\nreturn 1;}else{return[0,1];}}else{if(isTop){//上面所有节点\nreturn[0,3];}else if(isBottom){//下面所有节点\nreturn[1,2];}//对象跨越了4个节点\nreturn[0,1,2,3];}}return-1;};this.getObjectsByBound=function(objBound){var returnObjs=_this4.objects;if(_this4.childNodes){var index=_this4.getIndex(objBound);if(index>-1){var objList=_this4.childNodes[index].getObjectsByBound(objBound);// returnObjs = returnObjs.concat( objList );\nreturnObjs=objList;}else if(index!==-1){//如果目标对象跨越2个以上节点\nreturnObjs=[];index.forEach(function(item){var objList=this.childNodes[item].getObjectsByBound(objBound);returnObjs=returnObjs.concat(objList);},_this4);}}return returnObjs;};};var Rect=function Rect(x,y,w,h){var _this3=this;_classCallCheck(this,Rect);this.move=function(){var step=1;// (this.stepX < 0) && (step = -step);\n_this3.stepX<0&&(step*=-1);_this3.bound.left+=step;if(_this3.bound.left<0||_this3.bound.left+_this3.bound.width>Rect.right){_this3.stepX=-step;}step=1;// (this.stepY < 0) && (step = -step);\n_this3.stepY<0&&(step*=-1);_this3.bound.top+=step;if(_this3.bound.top<0||_this3.bound.top+_this3.bound.height>Rect.bottom){_this3.stepY=-step;}};this.bound={'left':x,'top':y,'width':w,'height':h};this.stepX=Math.random()<0.5?-1:1;this.stepY=Math.random()<0.5?-1:1;};function renderQuadTree(cvs){var ctx=cvs.getContext('2d');var cvsWidth=cvs.width,cvsHeight=cvs.height;var objList=[];var unitWidth=10,unitHeight=10;var maxWidth=cvsWidth-unitWidth;var maxHeight=cvsHeight-unitHeight;Rect.right=cvsWidth;Rect.bottom=cvsHeight;for(var i=0;i<100;i++){objList.push(new Rect(Math.random()*maxWidth>>0,Math.random()*maxHeight>>0,unitWidth,unitHeight));}var quadTree=new QuadTree(cvsWidth,cvsHeight);quadTree.setObjects(objList);quadTree.render(ctx);var animateInit={animateId:0,cleanQuadTree:function cleanQuadTree(){window.cancelAnimationFrame(this.animateId);}};var lasttime=0;function mainLoop(timepass){ctx.clearRect(0,0,cvsWidth,cvsHeight);quadTree.clear();objList.forEach(function(rect){rect.move();rect.overlap=false;});quadTree.setObjects(objList);quadTree.render(ctx);var fps=1000/(timepass-lasttime)>>0;ctx.fillText('FPS '+fps,5,15);lasttime=timepass;animateInit.animateId=window.requestAnimationFrame(mainLoop);}mainLoop();return animateInit;}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/1.85d4732e.chunk.js","import React, { Component } from 'react';\n\nimport { renderQuadTree } from '../lib/QuadTree';\n\nexport default class QuadTreeComp extends Component {\n\n  canvasRef = null;\n\n  quadHandler = null;\n\n  handleRef = (ref) => {\n    if (ref) {\n      this.handleRef = ref;\n      this.quadHandler = renderQuadTree(this.handleRef);\n    } else {\n\n      this.quadHandler.cleanQuadTree();\n    }\n  }\n\n  render() {\n    return <section className='topic-body'>\n      <h4>四叉树碰撞检测</h4>\n      <canvas ref={this.handleRef}></canvas>\n    </section>;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/parts/QuadTreeComp.js","class QuadTree {\n  static maxObjPerNode = 5;\n  static maxLevel = 5;\n  root;\n  constructor(width, height) {\n    this.root = new Node({\n      'left': 0,\n      'top': 0,\n      'width': width,\n      'height': height\n    }, 1);\n  }\n  setObjects = (objList) => {\n    if (objList instanceof Array) {\n      objList.forEach(function (item) {\n        this.root.add(item);\n      }, this);\n    } else {\n      this.root.add(objList);\n    }\n\n    this.root.collision();\n  }\n\n  clear = () => {\n    this.root.clear();\n  }\n\n  render = (ctx) => {\n    this.root.drawNode(ctx);\n  }\n\n  /*\n   *显示指定区域内的对象\n   */\n  showTargets = (ctx, rect) => {\n    let objList = this.root.getObjectsByBound(rect);\n\n    objList.forEach(function (item) {\n      let bound = item.bound;\n      ctx.fillStyle = '#F00';\n      ctx.fillRect(bound.left, bound.top, bound.width, bound.height);\n    });\n  }\n}\n\n\n\n\n\nclass Node {\n\n  /*\n   **计算当前对象属于四个节点中的哪个\n   * -1表示父节点\n   * 0：左上\n   * 1：左下\n   * 2：右下\n   * 3：右上\n   * 如果返回值是一个数组，说明当前对象跨越了2个以上节点\n   */\n  static LEFT_TOP = 0;\n  static LEFT_BOTTOM = 1;\n  static RIGHT_BOTTOM = 2;\n  static RIGHT_TOP = 3;\n\n  /*\n   *bound 当前节点占据的范围\n   *objects 要添加到节点上的对象数组\n   *bound:{left, top, width, height}\n   */\n  constructor(bound, level) {\n    this.objects = [];\n    this.childNodes = null;\n    this.bound = bound;\n    this.level = level;\n    this.cleaned = true; //用来区分节点是不是被清除过\n  }\n\n  drawNode = (ctx) => {\n\n    let bound = this.bound;\n\n    this.childNodes && this.childNodes.forEach(function (item) {\n      item.drawNode(ctx);\n    });\n\n    this.objects.length > 0 && ctx.strokeRect(bound.left, bound.top, bound.width, bound.height);\n\n    let overlapObj = [];\n    this.objects.forEach(function (obj) {\n\n      let bd = obj.bound;\n\n      ctx.strokeRect(bd.left, bd.top, bd.width, bd.height);\n\n      obj.overlap && overlapObj.push(bd);\n\n    });\n\n    ctx.save();\n    ctx.fillStyle = '#F00';\n    overlapObj.forEach(function (bound) {\n\n      ctx.fillRect(bound.left, bound.top, bound.width, bound.height);\n\n    });\n    ctx.restore();\n  }\n\n  clear = () => {\n    if (this.childNodes) {\n      this.childNodes.forEach(function (child) {\n        child.clear();\n      });\n    }\n    this.cleaned = true;\n    this.objects.length = 0;\n  }\n\n  collision = () => {\n\n    let childNodes = this.childNodes;\n\n    if (childNodes) {\n\n      childNodes.forEach(function (item) {\n        item.collision();\n      });\n\n      let _this = this;\n      //对于跨域不同象限的对象，根据对象所属的象限，取出对应象限内所有的对象\n      this.objects.forEach(function (item) {\n\n        let objects = _this.getObjectsByBound(item.bound);\n\n        objects.forEach(function (obj) {\n          if (_this.rectOverRect(item.bound, obj.bound)) {\n            obj.overlap = item.overlap = true;\n          }\n        });\n\n      });\n\n    }\n    let objs = this.objects;\n    for (let i = 0, size = objs.length; i < size; i++) {\n      for (let k = i + 1; k < size; k++) {\n        if (this.rectOverRect(objs[i].bound, objs[k].bound)) {\n          objs[i].overlap = objs[k].overlap = true;\n        }\n      }\n    }\n\n  }\n\n  rectOverRect = (bound1, bound2) => {\n    return !(bound1.left + bound1.width < bound2.left ||\n      bound1.left > bound2.left + bound2.width ||\n      bound1.top + bound1.height < bound2.top ||\n      bound1.top > bound2.top + bound2.height);\n  }\n\n  add = (obj) => {\n\n    if (!obj || !obj.bound) {\n      throw new TypeError('arguments must contain {bound}');\n    }\n\n    if (!this.cleaned && this.childNodes && this.childNodes.length > 0) {\n\n      let index = this.getIndex(obj.bound);\n\n      if (index > -1) {\n        return this.childNodes[index].add(obj);\n      }\n\n    } else if (this.objects.length > QuadTree.maxObjPerNode && this.level < QuadTree.maxLevel) {\n\n      this.split();\n\n      let index = this.getIndex(obj.bound);\n\n      if (index > -1) {\n        return this.childNodes[index].add(obj);\n      }\n\n    }\n\n    //obj.quadrant = index;\n    this.objects.push(obj);\n\n  }\n\n  /**\n   * 分裂节点\n   */\n  split = () => {\n    let bound = this.bound;\n\n    let halfWidth = (bound.width / 2) >> 0,\n      halfHeight = (bound.height / 2) >> 0;\n\n    let level = this.level + 1;\n\n    !this.childNodes && (this.childNodes = [\n      new Node({\n        'left': bound.left,\n        'top': bound.top,\n        'width': halfWidth,\n        'height': halfHeight\n      }, level), //0：左上\n\n      new Node({\n        'left': bound.left,\n        'top': bound.top + halfHeight,\n        'width': halfWidth,\n        'height': halfHeight\n      }, level), //1：左下\n\n      new Node({\n        'left': bound.left + halfWidth,\n        'top': bound.top + halfHeight,\n        'width': halfWidth,\n        'height': halfHeight\n      }, level), //2：右下\n\n      new Node({\n        'left': bound.left + halfWidth,\n        'top': bound.top,\n        'width': halfWidth,\n        'height': halfHeight\n      }, level) //3：右上\n    ]);\n\n    let tmpObjects = [];\n\n    this.objects.forEach(function (item) {\n      let index = this.getIndex(item.bound);\n\n      if (-1 < index) {\n        this.childNodes[index].add(item);\n      } else {\n        tmpObjects.push(item);\n      }\n\n    }, this);\n    this.cleaned = false;\n    this.objects = tmpObjects;\n  }\n\n  getIndex = (objRect) => {\n    if (this.childNodes) {\n\n      let rightBottomNode = this.childNodes[2].bound;\n\n      let isBottom = objRect.top >= rightBottomNode.top;\n      let isTop = objRect.top + objRect.height <= rightBottomNode.top;\n\n      //判断位置是偏右还是偏左\n      if (objRect.left >= rightBottomNode.left) {\n        //偏右\n        if (isTop) {\n          //右上\n          return 3;\n        } else if (isBottom) {\n          //右下\n          return 2;\n        } else {\n          return [2, 3];\n        }\n      } else if (objRect.left + objRect.width <= rightBottomNode.left) {\n        //偏左\n        if (isTop) {\n          //左上\n          return 0;\n        } else if (isBottom) {\n          //左下\n          return 1;\n        } else {\n          return [0, 1];\n        }\n      } else {\n\n        if (isTop) {\n          //上面所有节点\n          return [0, 3];\n        } else if (isBottom) {\n          //下面所有节点\n          return [1, 2];\n        }\n\n        //对象跨越了4个节点\n        return [0, 1, 2, 3];\n      }\n    }\n    return -1;\n  }\n  /*\n   *获取某个范围内的对象\n   */\n  getObjectsByBound = (objBound) => {\n\n    let returnObjs = this.objects;\n\n    if (this.childNodes) {\n      let index = this.getIndex(objBound);\n\n      if (index > -1) {\n        let objList = this.childNodes[index].getObjectsByBound(objBound);\n        // returnObjs = returnObjs.concat( objList );\n        returnObjs = objList;\n      } else if (index !== -1) {\n        //如果目标对象跨越2个以上节点\n        returnObjs = [];\n        index.forEach(function (item) {\n          let objList = this.childNodes[item].getObjectsByBound(objBound);\n          returnObjs = returnObjs.concat(objList);\n\n        }, this);\n\n      }\n    }\n    return returnObjs;\n  }\n}\n\nclass Rect {\n  static right;\n  static bottom;\n\n  constructor(x, y, w, h) {\n    this.bound = {\n      'left': x,\n      'top': y,\n      'width': w,\n      'height': h\n    };\n    this.stepX = Math.random() < 0.5 ? -1 : 1;\n    this.stepY = Math.random() < 0.5 ? -1 : 1;\n  }\n\n  move = () => {\n    let step = 1;\n    // (this.stepX < 0) && (step = -step);\n    (this.stepX < 0) && (step *= -1);\n\n    this.bound.left += step;\n\n    if (this.bound.left < 0 || this.bound.left + this.bound.width > Rect.right) {\n      this.stepX = -step;\n    }\n\n    step = 1;\n    // (this.stepY < 0) && (step = -step);\n    (this.stepY < 0) && (step *= -1);\n\n    this.bound.top += step;\n\n    if (this.bound.top < 0 || this.bound.top + this.bound.height > Rect.bottom) {\n      this.stepY = -step;\n    }\n  }\n}\n\nexport function renderQuadTree(cvs) {\n  let ctx = cvs.getContext('2d');\n\n  let cvsWidth = cvs.width,\n    cvsHeight = cvs.height;\n\n  let objList = [];\n\n  let [unitWidth, unitHeight] = [10, 10];\n\n  let maxWidth = cvsWidth - unitWidth;\n  let maxHeight = cvsHeight - unitHeight;\n\n  Rect.right = cvsWidth;\n  Rect.bottom = cvsHeight;\n\n  for (let i = 0; i < 100; i++) {\n\n    objList.push(new Rect((Math.random() * maxWidth) >> 0,\n      (Math.random() * maxHeight) >> 0,\n      unitWidth, unitHeight));\n  }\n\n  let quadTree = new QuadTree(cvsWidth, cvsHeight);\n\n  quadTree.setObjects(objList);\n\n  quadTree.render(ctx);\n\n  const animateInit = {\n    animateId: 0,\n    cleanQuadTree() {\n      window.cancelAnimationFrame(this.animateId);\n    }\n  };\n\n  let lasttime = 0;\n\n  function mainLoop(timepass) {\n\n    ctx.clearRect(0, 0, cvsWidth, cvsHeight);\n\n    quadTree.clear();\n\n    objList.forEach(function (rect) {\n      rect.move();\n      rect.overlap = false;\n    });\n\n    quadTree.setObjects(objList);\n    quadTree.render(ctx);\n    let fps = (1000 / (timepass - lasttime)) >> 0;\n    ctx.fillText(`FPS ${fps}`, 5, 15);\n    lasttime = timepass;\n    animateInit.animateId = window.requestAnimationFrame(mainLoop);\n  }\n  mainLoop();\n\n  return animateInit;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/lib/QuadTree.js"],"sourceRoot":""}